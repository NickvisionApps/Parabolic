#include "models/previousdownloadoptions.h"
#include <libnick/filesystem/userdirectories.h>
#include "models/format.h"

using namespace Nickvision::Filesystem;
using namespace Nickvision::Helpers;

namespace Nickvision::TubeConverter::Shared::Models
{
    PreviousDownloadOptions::PreviousDownloadOptions(const std::filesystem::path& path)
        : JsonFileBase{ path }
    {

    }

    std::filesystem::path PreviousDownloadOptions::getSaveFolder() const
    {
        std::filesystem::path path{ get("SaveFolder", UserDirectories::get(UserDirectory::Downloads).string()) };
        if(std::filesystem::exists(path))
        {
            return path.make_preferred();
        }
        return UserDirectories::get(UserDirectory::Downloads).make_preferred();
    }

    void PreviousDownloadOptions::setSaveFolder(std::filesystem::path previousSaveFolder)
    {
        if(std::filesystem::exists(previousSaveFolder))
        {
            set("SaveFolder", previousSaveFolder.make_preferred().string());
        }
        else
        {
            set("SaveFolder", UserDirectories::get(UserDirectory::Downloads).make_preferred().string());
        }
    }

    MediaFileType PreviousDownloadOptions::getFileType() const
    {
        return { static_cast<MediaFileType::MediaFileTypeValue>(get("FileType", static_cast<int>(MediaFileType::MP4))) };
    }

    void PreviousDownloadOptions::setFileType(const MediaFileType& previousMediaFileType)
    {
        set("FileType", static_cast<int>(previousMediaFileType));
    }

    std::string PreviousDownloadOptions::getVideoFormatId(const MediaFileType& type) const
    {
        static Format bestVideoFormat{ FormatValue::Best, MediaType::Video };
        static Format noneVideoFormat{ FormatValue::None, MediaType::Video };
        return get<std::string>("VideoFormatId_" + type.str(), type.isAudio() ? noneVideoFormat.getId() : bestVideoFormat.getId());
    }

    void PreviousDownloadOptions::setVideoFormatId(const MediaFileType& type, const std::string& videoFormatId)
    {
        set("VideoFormatId_" + type.str(), videoFormatId);
    }

    std::string PreviousDownloadOptions::getAudioFormatId(const MediaFileType& type) const
    {
        static Format bestAudioFormat{ FormatValue::Best, MediaType::Audio };
        return get<std::string>("AudioFormatId_" + type.str(), bestAudioFormat.getId());
    }

    void PreviousDownloadOptions::setAudioFormatId(const MediaFileType& type, const std::string& audioFormatId)
    {
        set("AudioFormatId_" + type.str(), audioFormatId);
    }

    bool PreviousDownloadOptions::getSplitChapters() const
    {
        return get<bool>("SplitChapters", false);
    }

    void PreviousDownloadOptions::setSplitChapters(bool splitChapters)
    {
        set("SplitChapters", splitChapters);
    }

    bool PreviousDownloadOptions::getExportDescription() const
    {
        return get<bool>("ExportDescription", false);
    }

    void PreviousDownloadOptions::setExportDescription(bool exportDescription)
    {
        set("ExportDescription", exportDescription);
    }

    std::string PreviousDownloadOptions::getPostProcessorArgument() const
    {
        return get<std::string>("PostProcessorArgument", "");
    }

    void PreviousDownloadOptions::setPostProcessorArgument(const std::string& postProcessorArgument)
    {
        set("PostProcessorArgument", postProcessorArgument);
    }

    bool PreviousDownloadOptions::getWritePlaylistFile() const
    {
        return get<bool>("WritePlaylistFile", false);
    }

    void PreviousDownloadOptions::setWritePlaylistFile(bool writePlaylistFile)
    {
        set("WritePlaylistFile", writePlaylistFile);
    }

    bool PreviousDownloadOptions::getNumberTitles() const
    {
        return get<bool>("NumberTitles", false);
    }

    void PreviousDownloadOptions::setNumberTitles(bool numberTitles)
    {
        set("NumberTitles", numberTitles);
    }

    std::vector<SubtitleLanguage> PreviousDownloadOptions::getSubtitleLanguages() const
    {
        std::vector<SubtitleLanguage> languages;
        boost::json::array jsonLanguages = get<boost::json::array>("SubtitleLanguages", {});
        for(const boost::json::value& language : jsonLanguages)
        {
            if(language.is_object())
            {
                boost::json::object obj = language.as_object();
                languages.push_back({ obj["Language"].is_string() ? obj["Language"].as_string().c_str() : "", obj["AutoGenerated"].is_bool() ? obj["AutoGenerated"].as_bool() : false });
            }
        }
        return languages;
    }

    void PreviousDownloadOptions::setSubtitleLanguages(const std::vector<SubtitleLanguage>& previousSubtitleLanguages)
    {
        boost::json::array languages;
        for(const SubtitleLanguage& language : previousSubtitleLanguages)
        {
            boost::json::object obj;
            obj["Language"] = language.getLanguage();
            obj["AutoGenerated"] = language.isAutoGenerated();
            languages.push_back(obj);
        }
        set("SubtitleLanguages", languages);
    }
}
