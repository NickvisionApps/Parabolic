#include "models/downloaderoptions.h"
#include <algorithm>
#include <thread>
#include <libnick/system/environment.h>

using namespace Nickvision::System;

namespace Nickvision::TubeConverter::Shared::Models
{
    DownloaderOptions::DownloaderOptions()
        : m_maxNumberOfActiveDownloads{ 5 },
        m_overwriteExistingFiles{ true },
        m_limitCharacters{ Environment::getOperatingSystem() == OperatingSystem::Windows },
        m_includeMediaIdInTitle{ true },
        m_includeAutoGeneratedSubtitles{ true },
        m_preferredVideoCodec{ VideoCodec::Any },
        m_preferredAudioCodec{ AudioCodec::Any },
        m_preferredSubtitleFormat{ SubtitleFormat::Any },
        m_usePartFiles{ true },
        m_youTubeSponsorBlock{ false },
        m_speedLimit{ std::nullopt },
        m_cookiesBrowser{ Browser::None },
        m_embedMetadata{ true },
        m_removeSourceData{ false },
        m_embedThumbnails{ true },
        m_cropAudioThumbnails{ false },
        m_embedChapters{ false },
        m_embedSubtitles{ true },
        m_postprocessingThreads{ static_cast<int>(std::thread::hardware_concurrency()) },
        m_useAria{ false },
        m_ariaMaxConnectionsPerServer{ 16 },
        m_ariaMinSplitSize{ 20 }
    {

    }

    int DownloaderOptions::getMaxNumberOfActiveDownloads() const
    {
        return m_maxNumberOfActiveDownloads;
    }

    void DownloaderOptions::setMaxNumberOfActiveDownloads(int max)
    {
        if(max < 1 || max > 10)
        {
            max = 5;
        }
        m_maxNumberOfActiveDownloads = max;
    }

    bool DownloaderOptions::getOverwriteExistingFiles() const
    {
        return m_overwriteExistingFiles;
    }

    void DownloaderOptions::setOverwriteExistingFiles(bool overwrite)
    {
        m_overwriteExistingFiles = overwrite;
    }

    bool DownloaderOptions::getLimitCharacters() const
    {
        return m_limitCharacters;
    }

    void DownloaderOptions::setLimitCharacters(bool limit)
    {
        m_limitCharacters = limit;
    }

    bool DownloaderOptions::getIncludeMediaIdInTitle() const
    {
        return m_includeMediaIdInTitle;
    }

    void DownloaderOptions::setIncludeMediaIdInTitle(bool include)
    {
        m_includeMediaIdInTitle = include;
    }

    bool DownloaderOptions::getIncludeAutoGeneratedSubtitles() const
    {
        return m_includeAutoGeneratedSubtitles;
    }

    void DownloaderOptions::setIncludeAutoGeneratedSubtitles(bool include)
    {
        m_includeAutoGeneratedSubtitles = include;
    }

    VideoCodec DownloaderOptions::getPreferredVideoCodec() const
    {
        return m_preferredVideoCodec;
    }

    void DownloaderOptions::setPreferredVideoCodec(VideoCodec codec)
    {
        m_preferredVideoCodec = codec;
    }

    AudioCodec DownloaderOptions::getPreferredAudioCodec() const
    {
        return m_preferredAudioCodec;
    }

    void DownloaderOptions::setPreferredAudioCodec(AudioCodec codec)
    {
        m_preferredAudioCodec = codec;
    }

    SubtitleFormat DownloaderOptions::getPreferredSubtitleFormat() const
    {
        return m_preferredSubtitleFormat;
    }

    void DownloaderOptions::setPreferredSubtitleFormat(SubtitleFormat format)
    {
        m_preferredSubtitleFormat = format;
    }

    bool DownloaderOptions::getUsePartFiles() const
    {
        return m_usePartFiles;
    }

    void DownloaderOptions::setUsePartFiles(bool part)
    {
        m_usePartFiles = part;
    }

    bool DownloaderOptions::getYouTubeSponsorBlock() const
    {
        return m_youTubeSponsorBlock;
    }

    void DownloaderOptions::setYouTubeSponsorBlock(bool sponsorBlock)
    {
        m_youTubeSponsorBlock = sponsorBlock;
    }

    const std::optional<int>& DownloaderOptions::getSpeedLimit() const
    {
        return m_speedLimit;
    }

    void DownloaderOptions::setSpeedLimit(const std::optional<int>& limit)
    {
        if(limit && (*limit < 512 || *limit > 10240))
        {
            m_speedLimit = 1024;
        }
        else
        {
            m_speedLimit = limit;
        }
    }

    const std::string& DownloaderOptions::getProxyUrl() const
    {
        return m_proxyUrl;
    }

    void DownloaderOptions::setProxyUrl(const std::string& proxyUrl)
    {
        m_proxyUrl = proxyUrl;
    }

    Browser DownloaderOptions::getCookiesBrowser() const
    {
        return m_cookiesBrowser;
    }

    void DownloaderOptions::setCookiesBrowser(Browser browser)
    {
        m_cookiesBrowser = browser;
    }

    const std::filesystem::path& DownloaderOptions::getCookiesPath() const
    {
        return m_cookiesPath;
    }

    void DownloaderOptions::setCookiesPath(const std::filesystem::path& path)
    {
        m_cookiesPath = path;
    }

    bool DownloaderOptions::getEmbedMetadata() const
    {
        return m_embedMetadata;
    }

    void DownloaderOptions::setEmbedMetadata(bool embedMetadata)
    {
        m_embedMetadata = embedMetadata;
    }

    bool DownloaderOptions::getRemoveSourceData() const
    {
        return m_removeSourceData;
    }

    void DownloaderOptions::setRemoveSourceData(bool removeSourceData)
    {
        m_removeSourceData = removeSourceData;
    }

    bool DownloaderOptions::getEmbedThumbnails() const
    {
        return m_embedThumbnails;
    }

    void DownloaderOptions::setEmbedThumbnails(bool embedThumbnails)
    {
        m_embedThumbnails = embedThumbnails;
    }

    bool DownloaderOptions::getCropAudioThumbnails() const
    {
        return m_cropAudioThumbnails;
    }

    void DownloaderOptions::setCropAudioThumbnails(bool cropAudioThumbnails)
    {
        m_cropAudioThumbnails = cropAudioThumbnails;
    }

    bool DownloaderOptions::getEmbedChapters() const
    {
        return m_embedChapters;
    }

    void DownloaderOptions::setEmbedChapters(bool embedChapters)
    {
        m_embedChapters = embedChapters;
    }

    bool DownloaderOptions::getEmbedSubtitles() const
    {
        return m_embedSubtitles;
    }

    void DownloaderOptions::setEmbedSubtitles(bool embedSubtitles)
    {
        m_embedSubtitles = embedSubtitles;
    }

    int DownloaderOptions::getPostprocessingThreads() const
    {
        return m_postprocessingThreads;
    }

    void DownloaderOptions::setPostprocessingThreads(int threads)
    {
        int hardwareThreads = static_cast<int>(std::thread::hardware_concurrency());
        if(threads < 1 || threads > hardwareThreads)
        {
            threads = hardwareThreads;
        }
        m_postprocessingThreads = threads;
    }

    const std::vector<PostProcessorArgument>& DownloaderOptions::getPostprocessingArguments() const
    {
        return m_postProcessingArguments;
    }

    void DownloaderOptions::setPostprocessingArguments(const std::vector<PostProcessorArgument>& args)
    {
        m_postProcessingArguments = args;
        std::sort(m_postProcessingArguments.begin(), m_postProcessingArguments.end());
    }

    bool DownloaderOptions::getUseAria() const
    {
        return m_useAria;
    }

    void DownloaderOptions::setUseAria(bool useAria)
    {
        m_useAria = useAria;
    }

    int DownloaderOptions::getAriaMaxConnectionsPerServer() const
    {
        return m_ariaMaxConnectionsPerServer;
    }

    void DownloaderOptions::setAriaMaxConnectionsPerServer(int maxConnections)
    {
        if(maxConnections < 1 || maxConnections > 16)
        {
            maxConnections = 16;
        }
        m_ariaMaxConnectionsPerServer = maxConnections;
    }

    int DownloaderOptions::getAriaMinSplitSize() const
    {
        return m_ariaMinSplitSize;
    }

    void DownloaderOptions::setAriaMinSplitSize(int minSplitSize)
    {
        if(minSplitSize < 1 || minSplitSize > 1024)
        {
            minSplitSize = 20;
        }
        m_ariaMinSplitSize = minSplitSize;
    }
}
