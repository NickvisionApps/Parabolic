#include "models/downloaderoptions.h"
#include <thread>
#include <libnick/system/environment.h>

using namespace Nickvision::System;

namespace Nickvision::TubeConverter::Shared::Models
{
    DownloaderOptions::DownloaderOptions()
        : m_overwriteExistingFiles{ true },
        m_maxNumberOfActiveDownloads{ 5 },
        m_limitCharacters{ Environment::getOperatingSystem() == OperatingSystem::Windows },
        m_includeAutoGeneratedSubtitles{ true },
        m_preferredVideoCodec{ VideoCodec::Any },
        m_useAria{ false },
        m_ariaMaxConnectionsPerServer{ 16 },
        m_ariaMinSplitSize{ 20 },
        m_speedLimit{ 1024 },
        m_proxyUrl{ "" },
        m_cookiesBrowser{ Browser::None },
        m_youTubeSponsorBlock{ false },
        m_embedMetadata{ true },
        m_cropAudioThumbnails{ false },
        m_removeSourceData{ false },
        m_embedChapters{ false },
        m_embedSubtitles{ true },
        m_postprocessingThreads{ static_cast<int>(std::thread::hardware_concurrency()) }
    {
        
    }

    DownloaderOptions::DownloaderOptions(boost::json::object json)
        : m_overwriteExistingFiles{ json["OverwriteExistingFiles"].is_bool() ? json["OverwriteExistingFiles"].as_bool() : true },
        m_maxNumberOfActiveDownloads{ json["MaxNumberOfActiveDownloads"].is_int64() ? static_cast<int>(json["MaxNumberOfActiveDownloads"].as_int64()) : 5 },
        m_limitCharacters{ json["LimitCharacters"].is_bool() ? json["LimitCharacters"].as_bool() : Environment::getOperatingSystem() == OperatingSystem::Windows },
        m_includeAutoGeneratedSubtitles{ json["IncludeAutoGeneratedSubtitles"].is_bool() ? json["IncludeAutoGeneratedSubtitles"].as_bool() : true },
        m_preferredVideoCodec{ json["PreferredVideoCodec"].is_int64() ? static_cast<VideoCodec>(json["PreferredVideoCodec"].as_int64()) : VideoCodec::Any },
        m_useAria{ json["UseAria"].is_bool() ? json["UseAria"].as_bool() : false },
        m_ariaMaxConnectionsPerServer{ json["AriaMaxConnectionsPerServer"].is_int64() ? static_cast<int>(json["AriaMaxConnectionsPerServer"].as_int64()) : 16 },
        m_ariaMinSplitSize{ json["AriaMinSplitSize"].is_int64() ? static_cast<int>(json["AriaMinSplitSize"].as_int64()) : 20 },
        m_speedLimit{ json["SpeedLimit"].is_int64() ? static_cast<unsigned int>(json["SpeedLimit"].as_int64()) : 1024 },
        m_proxyUrl{ json["ProxyUrl"].is_string() ? json["ProxyUrl"].as_string().c_str() : "" },
        m_cookiesBrowser{ json["CookiesBrowser"].is_int64() ? static_cast<Browser>(json["CookiesBrowser"].as_int64()) : Browser::None },
        m_cookiesPath{ json["CookiesPath"].is_string() ? json["CookiesPath"].as_string().c_str() : "" },
        m_youTubeSponsorBlock{ json["YouTubeSponsorBlock"].is_bool() ? json["YouTubeSponsorBlock"].as_bool() : false },
        m_embedMetadata{ json["EmbedMetadata"].is_bool() ? json["EmbedMetadata"].as_bool() : true },
        m_cropAudioThumbnails{ json["CropAudioThumbnails"].is_bool() ? json["CropAudioThumbnails"].as_bool() : false },
        m_removeSourceData{ json["RemoveSourceData"].is_bool() ? json["RemoveSourceData"].as_bool() : false },
        m_embedChapters{ json["EmbedChapters"].is_bool() ? json["EmbedChapters"].as_bool() : false },
        m_embedSubtitles{ json["EmbedSubtitle"].is_bool() ? json["EmbedSubtitle"].as_bool() : true },
        m_postprocessingThreads{ json["PostprocessingThreads"].is_int64() ? static_cast<int>(json["PostprocessingThreads"].as_int64()) : static_cast<int>(std::thread::hardware_concurrency()) }
    {

    }

    bool DownloaderOptions::getOverwriteExistingFiles() const
    {
        return m_overwriteExistingFiles;
    }

    void DownloaderOptions::setOverwriteExistingFiles(bool overwrite)
    {
        m_overwriteExistingFiles = overwrite;
    }

    int DownloaderOptions::getMaxNumberOfActiveDownloads() const
    {
        return m_maxNumberOfActiveDownloads;
    }

    void DownloaderOptions::setMaxNumberOfActiveDownloads(int max)
    {
        if(max < 1 || max > 10)
        {
            max = 5;
        }
        m_maxNumberOfActiveDownloads = max;
    }

    bool DownloaderOptions::getLimitCharacters() const
    {
        return m_limitCharacters;
    }

    void DownloaderOptions::setLimitCharacters(bool limit)
    {
        m_limitCharacters = limit;
    }

    bool DownloaderOptions::getIncludeAutoGeneratedSubtitles() const
    {
        return m_includeAutoGeneratedSubtitles;
    }

    void DownloaderOptions::setIncludeAutoGeneratedSubtitles(bool include)
    {
        m_includeAutoGeneratedSubtitles = include;
    }

    VideoCodec DownloaderOptions::getPreferredVideoCodec() const
    {
        return m_preferredVideoCodec;
    }

    void DownloaderOptions::setPreferredVideoCodec(VideoCodec codec)
    {
        m_preferredVideoCodec = codec;
    }

    bool DownloaderOptions::getUseAria() const
    {
        return m_useAria;
    }

    void DownloaderOptions::setUseAria(bool useAria)
    {
        m_useAria = useAria;
    }

    int DownloaderOptions::getAriaMaxConnectionsPerServer() const
    {
        return m_ariaMaxConnectionsPerServer;
    }

    void DownloaderOptions::setAriaMaxConnectionsPerServer(int maxConnections)
    {
        if(maxConnections < 1 || maxConnections > 16)
        {
            maxConnections = 16;
        }
        m_ariaMaxConnectionsPerServer = maxConnections;
    }

    int DownloaderOptions::getAriaMinSplitSize() const
    {
        return m_ariaMinSplitSize;
    }

    void DownloaderOptions::setAriaMinSplitSize(int minSplitSize)
    {
        if(minSplitSize < 1 || minSplitSize > 1024)
        {
            minSplitSize = 20;
        }
        m_ariaMinSplitSize = minSplitSize;
    }

    unsigned int DownloaderOptions::getSpeedLimit() const
    {
        return m_speedLimit;
    }

    void DownloaderOptions::setSpeedLimit(unsigned int speedLimit)
    {
        if(speedLimit < 512 || speedLimit > 10240)
        {
            speedLimit = 1024;
        }
        m_speedLimit = speedLimit;
    }

    const std::string& DownloaderOptions::getProxyUrl() const
    {
        return m_proxyUrl;
    }

    void DownloaderOptions::setProxyUrl(const std::string& proxyUrl)
    {
        m_proxyUrl = proxyUrl;
    }

    Browser DownloaderOptions::getCookiesBrowser() const
    {
        return m_cookiesBrowser;
    }

    void DownloaderOptions::setCookiesBrowser(Browser browser)
    {
        m_cookiesBrowser = browser;
    }

    const std::filesystem::path& DownloaderOptions::getCookiesPath() const
    {
        return m_cookiesPath;
    }

    void DownloaderOptions::setCookiesPath(const std::filesystem::path& path)
    {
        m_cookiesPath = path;
    }

    bool DownloaderOptions::getYouTubeSponsorBlock() const
    {
        return m_youTubeSponsorBlock;
    }

    void DownloaderOptions::setYouTubeSponsorBlock(bool sponsorBlock)
    {
        m_youTubeSponsorBlock = sponsorBlock;
    }

    bool DownloaderOptions::getEmbedMetadata() const
    {
        return m_embedMetadata;
    }

    void DownloaderOptions::setEmbedMetadata(bool embedMetadata)
    {
        m_embedMetadata = embedMetadata;
    }

    bool DownloaderOptions::getCropAudioThumbnails() const
    {
        return m_cropAudioThumbnails;
    }

    void DownloaderOptions::setCropAudioThumbnails(bool cropAudioThumbnails)
    {
        m_cropAudioThumbnails = cropAudioThumbnails;
    }

    bool DownloaderOptions::getRemoveSourceData() const
    {
        return m_removeSourceData;
    }

    void DownloaderOptions::setRemoveSourceData(bool removeSourceData)
    {
        m_removeSourceData = removeSourceData;
    }

    bool DownloaderOptions::getEmbedChapters() const
    {
        return m_embedChapters;
    }

    void DownloaderOptions::setEmbedChapters(bool embedChapters)
    {
        m_embedChapters = embedChapters;
    }

    bool DownloaderOptions::getEmbedSubtitles() const
    {
        return m_embedSubtitles;
    }

    void DownloaderOptions::setEmbedSubtitles(bool embedSubtitles)
    {
        m_embedSubtitles = embedSubtitles;
    }
    
    int DownloaderOptions::getPostprocessingThreads() const
    {
        return m_postprocessingThreads;
    }

    void DownloaderOptions::setPostprocessingThreads(int threads)
    {
        int hardwareThreads = static_cast<int>(std::thread::hardware_concurrency());
        if(threads < 1 || threads > hardwareThreads)
        {
            threads = hardwareThreads;
        }
        m_postprocessingThreads = threads;
    }

    boost::json::object DownloaderOptions::toJson() const
    {
        boost::json::object json;
        json["OverwriteExistingFiles"] = m_overwriteExistingFiles;
        json["MaxNumberOfActiveDownloads"] = m_maxNumberOfActiveDownloads;
        json["LimitCharacters"] = m_limitCharacters;
        json["IncludeAutoGeneratedSubtitles"] = m_includeAutoGeneratedSubtitles;
        json["PreferredVideoCodec"] = static_cast<int>(m_preferredVideoCodec);
        json["UseAria"] = m_useAria;
        json["AriaMaxConnectionsPerServer"] = m_ariaMaxConnectionsPerServer;
        json["AriaMinSplitSize"] = m_ariaMinSplitSize;
        json["SpeedLimit"] = m_speedLimit;
        json["ProxyUrl"] = m_proxyUrl;
        json["CookiesBrowser"] = static_cast<int>(m_cookiesBrowser);
        json["CookiesPath"] = m_cookiesPath.string();
        json["YouTubeSponsorBlock"] = m_youTubeSponsorBlock;
        json["EmbedMetadata"] = m_embedMetadata;
        json["CropAudioThumbnails"] = m_cropAudioThumbnails;
        json["RemoveSourceData"] = m_removeSourceData;
        json["EmbedChapters"] = m_embedChapters;
        json["EmbedSubtitle"] = m_embedSubtitles;
        json["PostprocessingThreads"] = m_postprocessingThreads;
        return json;
    }
}