#include "models/configuration.h"
#include <thread>
#include <libnick/system/environment.h>

using namespace Nickvision::App;
using namespace Nickvision::Helpers;
using namespace Nickvision::System;
using namespace Nickvision::Update;

namespace Nickvision::TubeConverter::Shared::Models
{
    Configuration::Configuration(const std::filesystem::path& path)
        : JsonFileBase{ path }
    {

    }

    Theme Configuration::getTheme() const
    {
        return static_cast<Theme>(get("Theme", static_cast<int>(Theme::System)));
    }

    void Configuration::setTheme(Theme theme)
    {
        set("Theme", static_cast<int>(theme));
    }

    std::string Configuration::getTranslationLanguage() const
    {
        return get<std::string>("TranslationLanguage", "");
    }

    void Configuration::setTranslationLanguage(const std::string& language)
    {
        set("TranslationLanguage", language);
    }

    WindowGeometry Configuration::getWindowGeometry() const
    {
        boost::json::object geometry = get<boost::json::object>("WindowGeometry", {});
        if(geometry.empty())
        {
            return { 800, 600, false };
        }
        return WindowGeometry(geometry);
    }

    void Configuration::setWindowGeometry(const WindowGeometry& geometry)
    {
        set("WindowGeometry", geometry.toJson().as_object());
    }

    VersionType Configuration::getPreferredUpdateType() const
    {
        return static_cast<VersionType>(get("PreferredUpdateType", static_cast<int>(VersionType::Stable)));
    }

    void Configuration::setPreferredUpdateType(VersionType type)
    {
        set("PreferredUpdateType", static_cast<int>(type));
    }

    Version Configuration::getInstalledYtdlpVersion() const
    {
        std::string verStr{ get<std::string>("InstalledYtdlpVersion", "") };
        return verStr.empty() ? Version() : Version(verStr);
    }

    void Configuration::setInstalledYtdlpVersion(const Version& version)
    {
        set("InstalledYtdlpVersion", version.str());
    }

    bool Configuration::getPreventSuspend() const
    {
        return get("PreventSuspend", false);
    }

    void Configuration::setPreventSuspend(bool prevent)
    {
        set("PreventSuspend", prevent);
    }

    DownloaderOptions Configuration::getDownloaderOptions() const
    {
        std::vector<PostProcessorArgument> postprocessingArguments;
        for(const boost::json::value& json : get<boost::json::array>("PostprocessingArguments", {}))
        {
            if(json.is_object())
            {
                postprocessingArguments.push_back(PostProcessorArgument(json.as_object()));
            }
        }
        DownloaderOptions options;
        options.setMaxNumberOfActiveDownloads(get("MaxNumberOfActiveDownloads", 5));
        options.setOverwriteExistingFiles(get("OverwriteExistingFiles", true));
        options.setLimitCharacters(get("LimitCharacters", Environment::getOperatingSystem() == OperatingSystem::Windows));
        options.setIncludeMediaIdInTitle(get("IncludeMediaIdInTitle", true));
        options.setIncludeAutoGeneratedSubtitles(get("IncludeAutoGeneratedSubtitles", true));
        options.setPreferredVideoCodec(static_cast<VideoCodec>(get("PreferredVideoCodec", static_cast<int>(VideoCodec::Any))));
        options.setPreferredAudioCodec(static_cast<AudioCodec>(get("PreferredAudioCodec", static_cast<int>(AudioCodec::Any))));
        options.setPreferredSubtitleFormat(static_cast<SubtitleFormat>(get("PreferredSubtitleFormat", static_cast<int>(SubtitleFormat::Any))));
        options.setUsePartFiles(get("UsePartFiles", true));
        options.setYouTubeSponsorBlock(get("YouTubeSponsorBlock", false));
        options.setSpeedLimit(get("SpeedLimitKB", 0) == 0 ? std::nullopt : std::make_optional(get("SpeedLimitKB", 0)));
        options.setProxyUrl(get<std::string>("ProxyUrl", ""));
        options.setCookiesBrowser(static_cast<Browser>(get("CookiesBrowser", static_cast<int>(Browser::None))));
        options.setCookiesPath(get<std::string>("CookiesPath", ""));
        options.setEmbedMetadata(get("EmbedMetadata", true));
        options.setRemoveSourceData(get("RemoveSourceData", false));
        options.setEmbedThumbnails(get("EmbedThumbnails", true));
        options.setCropAudioThumbnails(get("CropAudioThumbnails", false));
        options.setEmbedChapters(get("EmbedChapters", false));
        options.setEmbedSubtitles(get("EmbedSubtitle", true));
        options.setPostprocessingThreads(get("PostprocessingThreads", static_cast<int>(std::thread::hardware_concurrency())));
        options.setPostprocessingArguments(postprocessingArguments);
        options.setUseAria(get("UseAria", false));
        options.setAriaMaxConnectionsPerServer(get("AriaMaxConnectionsPerServer", 16));
        options.setAriaMinSplitSize(get("AriaMinSplitSize", 20));
        return options;
    }

    void Configuration::setDownloaderOptions(const DownloaderOptions& downloaderOptions)
    {
        boost::json::array postprocessingArguments;
        for(const PostProcessorArgument& args : downloaderOptions.getPostprocessingArguments())
        {
            postprocessingArguments.push_back(args.toJson());
        }
        set("MaxNumberOfActiveDownloads", downloaderOptions.getMaxNumberOfActiveDownloads());
        set("OverwriteExistingFiles", downloaderOptions.getOverwriteExistingFiles());
        set("LimitCharacters", downloaderOptions.getLimitCharacters());
        set("IncludeMediaIdInTitle", downloaderOptions.getIncludeMediaIdInTitle());
        set("IncludeAutoGeneratedSubtitles", downloaderOptions.getIncludeAutoGeneratedSubtitles());
        set("PreferredVideoCodec", static_cast<int>(downloaderOptions.getPreferredVideoCodec()));
        set("PreferredAudioCodec", static_cast<int>(downloaderOptions.getPreferredAudioCodec()));
        set("PreferredSubtitleFormat", static_cast<int>(downloaderOptions.getPreferredSubtitleFormat()));
        set("UsePartFiles", downloaderOptions.getUsePartFiles());
        set("YouTubeSponsorBlock", downloaderOptions.getYouTubeSponsorBlock());
        set("SpeedLimitKB", downloaderOptions.getSpeedLimit() ? *downloaderOptions.getSpeedLimit() : boost::json::object());
        set("ProxyUrl", downloaderOptions.getProxyUrl());
        set("CookiesBrowser", static_cast<int>(downloaderOptions.getCookiesBrowser()));
        set("CookiesPath", downloaderOptions.getCookiesPath().string());
        set("EmbedMetadata", downloaderOptions.getEmbedMetadata());
        set("RemoveSourceData", downloaderOptions.getRemoveSourceData());
        set("EmbedThumbnails", downloaderOptions.getEmbedThumbnails());
        set("CropAudioThumbnails", downloaderOptions.getCropAudioThumbnails());
        set("EmbedChapters", downloaderOptions.getEmbedChapters());
        set("EmbedSubtitle", downloaderOptions.getEmbedSubtitles());
        set("PostprocessingThreads", downloaderOptions.getPostprocessingThreads());
        set("PostprocessingArguments", postprocessingArguments);
        set("UseAria", downloaderOptions.getUseAria());
        set("AriaMaxConnectionsPerServer", downloaderOptions.getAriaMaxConnectionsPerServer());
        set("AriaMinSplitSize", downloaderOptions.getAriaMinSplitSize());
    }

    bool Configuration::getShowDisclaimerOnStartup() const
    {
        return get("ShowDisclaimerOnStartup", true);
    }

    void Configuration::setShowDisclaimerOnStartup(bool showDisclaimerOnStartup)
    {
        set("ShowDisclaimerOnStartup", showDisclaimerOnStartup);
    }
}
