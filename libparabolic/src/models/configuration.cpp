#include "models/configuration.h"
#include <thread>
#include <libnick/system/environment.h>

using namespace Nickvision::App;
using namespace Nickvision::System;

namespace Nickvision::TubeConverter::Shared::Models
{
    Configuration::Configuration(const std::string& key, const std::string& appName)
        : DataFileBase{ key, appName }
    {
        
    }

    Theme Configuration::getTheme() const
    {
        return m_json["Theme"].is_int64() ? static_cast<Theme>(m_json["Theme"].as_int64()) : Theme::System;
    }

    void Configuration::setTheme(Theme theme)
    {
        m_json["Theme"] = static_cast<int>(theme);
    }

    WindowGeometry Configuration::getWindowGeometry() const
    {
        if(!m_json["WindowGeometry"].is_object())
        {
            return { 800, 600, false };
        }
        return WindowGeometry(m_json["WindowGeometry"].as_object());
    }

    void Configuration::setWindowGeometry(const WindowGeometry& geometry)
    {
        m_json["WindowGeometry"] = geometry.toJson();
    }

    bool Configuration::getAutomaticallyCheckForUpdates() const
    {
        return m_json["AutomaticallyCheckForUpdates"].is_bool() ? m_json["AutomaticallyCheckForUpdates"].as_bool() : Environment::getOperatingSystem() == OperatingSystem::Windows;
    }

    void Configuration::setAutomaticallyCheckForUpdates(bool check)
    {
        m_json["AutomaticallyCheckForUpdates"] = check;
    }

    bool Configuration::getPreventSuspend() const
    {
        return m_json["PreventSuspend"].is_bool() ? m_json["PreventSuspend"].as_bool() : false;
    }

    void Configuration::setPreventSuspend(bool prevent)
    {
        m_json["PreventSuspend"] = prevent;
    }

    DownloaderOptions Configuration::getDownloaderOptions() const
    {
        std::vector<PostProcessorArgument> postprocessingArguments;
        for(const boost::json::value& json : (m_json["PostprocessingArguments"].is_array() ? m_json["PostprocessingArguments"].as_array() : boost::json::array()))
        {
            if(json.is_object())
            {
                postprocessingArguments.push_back(PostProcessorArgument(json.as_object()));
            }
        }
        DownloaderOptions options;
        options.setMaxNumberOfActiveDownloads(m_json["MaxNumberOfActiveDownloads"].is_int64() ? static_cast<int>(m_json["MaxNumberOfActiveDownloads"].as_int64()) : 5);
        options.setOverwriteExistingFiles(m_json["OverwriteExistingFiles"].is_bool() ? m_json["OverwriteExistingFiles"].as_bool() : true);
        options.setLimitCharacters(m_json["LimitCharacters"].is_bool() ? m_json["LimitCharacters"].as_bool() : Environment::getOperatingSystem() == OperatingSystem::Windows);
        options.setIncludeMediaIdInTitle(m_json["IncludeMediaIdInTitle"].is_bool() ? m_json["IncludeMediaIdInTitle"].as_bool() : true);
        options.setIncludeAutoGeneratedSubtitles(m_json["IncludeAutoGeneratedSubtitles"].is_bool() ? m_json["IncludeAutoGeneratedSubtitles"].as_bool() : true);
        options.setPreferredVideoCodec(m_json["PreferredVideoCodec"].is_int64() ? static_cast<VideoCodec>(m_json["PreferredVideoCodec"].as_int64()) : VideoCodec::Any);
        options.setPreferredAudioCodec(m_json["PreferredAudioCodec"].is_int64() ? static_cast<AudioCodec>(m_json["PreferredAudioCodec"].as_int64()) : AudioCodec::Any);
        options.setPreferredSubtitleFormat(m_json["PreferredSubtitleFormat"].is_int64() ? static_cast<SubtitleFormat>(m_json["PreferredSubtitleFormat"].as_int64()) : SubtitleFormat::Any);
        options.setUsePartFiles(m_json["UsePartFiles"].is_bool() ? m_json["UsePartFiles"].as_bool() : true);
        options.setYouTubeSponsorBlock(m_json["YouTubeSponsorBlock"].is_bool() ? m_json["YouTubeSponsorBlock"].as_bool() : false);
        options.setSpeedLimit(m_json["SpeedLimitKB"].is_int64() ? std::make_optional<int>(m_json["SpeedLimitKB"].as_int64()) : std::nullopt);
        options.setProxyUrl(m_json["ProxyUrl"].is_string() ? m_json["ProxyUrl"].as_string().c_str() : "");
        options.setCookiesBrowser(m_json["CookiesBrowser"].is_int64() ? static_cast<Browser>(m_json["CookiesBrowser"].as_int64()) : Browser::None);
        options.setCookiesPath(m_json["CookiesPath"].is_string() ? m_json["CookiesPath"].as_string().c_str() : "");
        options.setEmbedMetadata(m_json["EmbedMetadata"].is_bool() ? m_json["EmbedMetadata"].as_bool() : true);
        options.setRemoveSourceData(m_json["RemoveSourceData"].is_bool() ? m_json["RemoveSourceData"].as_bool() : false);
        options.setEmbedThumbnails(m_json["EmbedThumbnails"].is_bool() ? m_json["EmbedThumbnails"].as_bool() : true);
        options.setCropAudioThumbnails(m_json["CropAudioThumbnails"].is_bool() ? m_json["CropAudioThumbnails"].as_bool() : false);
        options.setEmbedChapters(m_json["EmbedChapters"].is_bool() ? m_json["EmbedChapters"].as_bool() : false);
        options.setEmbedSubtitles(m_json["EmbedSubtitle"].is_bool() ? m_json["EmbedSubtitle"].as_bool() : true);
        options.setPostprocessingThreads(m_json["PostprocessingThreads"].is_int64() ? static_cast<int>(m_json["PostprocessingThreads"].as_int64()) : static_cast<int>(std::thread::hardware_concurrency()));
        options.setPostprocessingArguments(postprocessingArguments);
        options.setUseAria(m_json["UseAria"].is_bool() ? m_json["UseAria"].as_bool() : false);
        options.setAriaMaxConnectionsPerServer(m_json["AriaMaxConnectionsPerServer"].is_int64() ? static_cast<int>(m_json["AriaMaxConnectionsPerServer"].as_int64()) : 16);
        options.setAriaMinSplitSize(m_json["AriaMinSplitSize"].is_int64() ? static_cast<int>(m_json["AriaMinSplitSize"].as_int64()) : 20);
        return options;
    }

    void Configuration::setDownloaderOptions(const DownloaderOptions& downloaderOptions)
    {
        boost::json::array postprocessingArguments;
        for(const PostProcessorArgument& args : downloaderOptions.getPostprocessingArguments())
        {
            postprocessingArguments.push_back(args.toJson());
        }
        m_json["MaxNumberOfActiveDownloads"] = downloaderOptions.getMaxNumberOfActiveDownloads();
        m_json["OverwriteExistingFiles"] = downloaderOptions.getOverwriteExistingFiles();
        m_json["LimitCharacters"] = downloaderOptions.getLimitCharacters();
        m_json["IncludeMediaIdInTitle"] = downloaderOptions.getIncludeMediaIdInTitle();
        m_json["IncludeAutoGeneratedSubtitles"] = downloaderOptions.getIncludeAutoGeneratedSubtitles();
        m_json["PreferredVideoCodec"] = static_cast<int>(downloaderOptions.getPreferredVideoCodec());
        m_json["PreferredAudioCodec"] = static_cast<int>(downloaderOptions.getPreferredAudioCodec());
        m_json["PreferredSubtitleFormat"] = static_cast<int>(downloaderOptions.getPreferredSubtitleFormat());
        m_json["UsePartFiles"] = downloaderOptions.getUsePartFiles();
        m_json["YouTubeSponsorBlock"] = downloaderOptions.getYouTubeSponsorBlock();
        m_json["SpeedLimitKB"] = downloaderOptions.getSpeedLimit() ? *downloaderOptions.getSpeedLimit() : boost::json::value(nullptr);
        m_json["ProxyUrl"] = downloaderOptions.getProxyUrl();
        m_json["CookiesBrowser"] = static_cast<int>(downloaderOptions.getCookiesBrowser());
        m_json["CookiesPath"] = downloaderOptions.getCookiesPath().string();
        m_json["EmbedMetadata"] = downloaderOptions.getEmbedMetadata();
        m_json["RemoveSourceData"] = downloaderOptions.getRemoveSourceData();
        m_json["EmbedThumbnails"] = downloaderOptions.getEmbedThumbnails();
        m_json["CropAudioThumbnails"] = downloaderOptions.getCropAudioThumbnails();
        m_json["EmbedChapters"] = downloaderOptions.getEmbedChapters();
        m_json["EmbedSubtitle"] = downloaderOptions.getEmbedSubtitles();
        m_json["PostprocessingThreads"] = downloaderOptions.getPostprocessingThreads();
        m_json["PostprocessingArguments"] = postprocessingArguments;
        m_json["UseAria"] = downloaderOptions.getUseAria();
        m_json["AriaMaxConnectionsPerServer"] = downloaderOptions.getAriaMaxConnectionsPerServer();
        m_json["AriaMinSplitSize"] = downloaderOptions.getAriaMinSplitSize();
    }

    bool Configuration::getShowDisclaimerOnStartup() const
    {
        return m_json["ShowDisclaimerOnStartup"].is_bool() ? m_json["ShowDisclaimerOnStartup"].as_bool() : true;
    }

    void Configuration::setShowDisclaimerOnStartup(bool showDisclaimerOnStartup)
    {
        m_json["ShowDisclaimerOnStartup"] = showDisclaimerOnStartup;
    }
}
