#ifndef CONFIGURATION_H
#define CONFIGURATION_H

#include <filesystem>
#include <string>
#include <libnick/app/configurationbase.h>
#include <libnick/app/windowgeometry.h>
#include "completednotificationpreference.h"
#include "mediafiletype.h"
#include "theme.h"
#include "videoresolution.h"

namespace Nickvision::TubeConverter::Shared::Models
{
    /**
     * @brief A model for the configuration of the application.
     */
    class Configuration : public Nickvision::App::ConfigurationBase
    {
    public:
        /**
         * @brief Constructs a Configuration.
         * @param key The key to pass to the ConfigurationBase
         */
        Configuration(const std::string& key);
        /**
         * @brief Gets the preferred theme for the application.
         * @return The preferred theme
         */
        Theme getTheme() const;
        /**
         * @brief Sets the preferred theme for the application.
         * @param theme The new preferred theme
         */
        void setTheme(Theme theme);
        /**
         * @brief Gets the window geometry for the application.
         * @return The window geometry
         */
        App::WindowGeometry getWindowGeometry() const;
        /**
         * @brief Sets the window geometry for the application.
         * @param geometry The new window geometry
         */
        void setWindowGeometry(const App::WindowGeometry& geometry);
        /**
         * @brief Gets whether or not to automatically check for application updates.
         * @return True to automatically check for updates, else false
         */
        bool getAutomaticallyCheckForUpdates() const;
        /**
         * @brief Sets whether or not to automatically check for application updates.
         * @param check Whether or not to automatically check for updates
         */
        void setAutomaticallyCheckForUpdates(bool check);
        /**
         * @brief Gets the completed notification preference for downloads.
         * @return The completed notification preference
         */
        CompletedNotificationPreference getCompletedNotificationPreference() const;
        /**
         * @brief Sets the completed notification preference for downloads.
         * @param preference The new completed notification preference
         */
        void setCompletedNotificationPreference(CompletedNotificationPreference preference);
        /**
         * @brief Gets whether or not to prevent the system from suspending when downloading.
         * @return True to prevent the system from suspending, else false
         */
        bool getPreventSuspendWhenDownloading() const;
        /**
         * @brief Sets whether or not to prevent the system from suspending when downloading.
         * @param prevent True to prevent the system from suspending, else false
         */
        void setPreventSuspendWhenDownloading(bool prevent);
        /**
         * @brief Gets whether or not to overwrite existing files.
         * @return True to overwrite existing files, else false
         */
        bool getOverwriteExistingFiles() const;
        /**
         * @brief Sets whether or not to overwrite existing files.
         * @param overwrite True to overwrite existing files, else false
         */
        void setOverwriteExistingFiles(bool overwrite);
        /**
         * @brief Gets the maximum number of active downloads.
         * @brief Should be between 1 and 10.
         * @return The maximum number of active downloads
         */
        int getMaxNumberOfActiveDownloads() const;
        /**
         * @brief Sets the maximum number of active downloads.
         * @param max The new maximum number of active downloads
         */
        void setMaxNumberOfActiveDownloads(int max);
        /**
         * @brief Gets whether or not to limit character to those supported by Windows only.
         * @return True to limit characters, else false
         */
        bool getLimitCharacters() const;
        /**
         * @brief Sets whether or not to limit character to those supported by Windows only.
         * @param limit True to limit characters, else false
         */
        void setLimitCharacters(bool limit);
        /**
         * @brief Gets whether or not to include auto-generated subtitles.
         * @return True to include auto-generated subtitles, else false
         */
        bool getIncludeAutoGeneratedSubtitles() const;
        /**
         * @brief Sets whether or not to include auto-generated subtitles.
         * @param include True to include auto-generated subtitles, else false
         */
        void setIncludeAutoGeneratedSubtitles(bool include);
        /**
         * @brief Gets whether or not to use aria2 for downloading.
         * @return True to use aria2, else false
         */
        bool getUseAria() const;
        /**
         * @brief Sets whether or not to use aria2 for downloading.
         * @param useAria True to use aria2, else false
         */
        void setUseAria(bool useAria);
        /**
         * @brief Gets the maximum number of connections per server for each aria2 download.
         * @brief This is equivalent to the -x flag in aria2.
         * @brief Should be between 1 and 16.
         * @return The maximum number of connections per server
         */
        int getAriaMaxConnectionsPerServer() const;
        /**
         * @brief Sets the maximum number of connections per server for each aria2 download.
         * @brief This is equivalent to the -x flag in aria2.
         * @brief Should be between 1 and 16.
         * @param maxConnections The new maximum number of connections per server
         */
        void setAriaMaxConnectionsPerServer(int maxConnections);
        /**
         * @brief Gets the minimum split size for each aria2 download.
         * @brief This is equivalent to the -k flag in aria2.
         * @brief Should be in MiB/s.
         * @brief Should be between 1 and 1024.
         * @return The minimum split size
         */
        int getAriaMinSplitSize() const;
        /**
         * @brief Sets the minimum split size for each aria2 download.
         * @brief This is equivalent to the -k flag in aria2.
         * @brief Should be in MiB/s.
         * @brief Should be between 1 and 1024.
         * @param minSplitSize The new minimum split size
         */
        void setAriaMinSplitSize(int minSplitSize);
        /**
         * @brief Gets the speed limit for each download.
         * @brief Should be in KiB/s.
         * @brief Should be between 512 and 10240.
         * @return The speed limit
         */
        unsigned int getSpeedLimit() const;
        /**
         * @brief Sets the speed limit for each download.
         * @brief Should be in KiB/s.
         * @brief Should be between 512 and 10240.
         * @param speedLimit The new speed limit
         */
        void setSpeedLimit(unsigned int speedLimit);
        /**
         * @brief Gets the proxy server url to use for downloading.
         * @return The proxy server url
         */
        std::string getProxyUrl() const;
        /**
         * @brief Sets the proxy server url to use for downloading.
         * @param proxyUrl The new proxy server url
         */
        void setProxyUrl(const std::string& proxyUrl);
        /**
         * @brief Gets the path to the cookies file to pass to the downloader.
         * @return The path to the cookies file
         */
        std::filesystem::path getCookiesPath() const;
        /**
         * @brief Sets the path to the cookies file to pass to the downloader.
         * @param cookiesPath The new path to the cookies file
         */
        void setCookiesPath(const std::filesystem::path& cookiesPath);
        /**
         * @brief Gets whether or not to use the YouTube SponsorBlock extension.
         * @return True to use SponsorBlock, else false
         */
        bool getYouTubeSponsorBlock() const;
        /**
         * @brief Sets whether or not to use the YouTube SponsorBlock extension.
         * @param sponsorBlock True to use SponsorBlock, else false
         */
        void setYouTubeSponsorBlock(bool sponsorBlock);
        /**
         * @brief Gets whether or not to disallow conversions.
         * @return True to disallow conversions, else false
         */
        bool getDisallowConversions() const;
        /**
         * @brief Sets whether or not to disallow conversions.
         * @param disallowConversions True to disallow conversions, else false
         */
        void setDisallowConversions(bool disallowConversions);
        /**
         * @brief Gets whether or not to embed metadata.
         * @return True to embed metadata, else false
         */
        bool getEmbedMetadata() const;
        /**
         * @brief Sets whether or not to embed metadata.
         * @param embedMetadata True to embed metadata, else false
         */
        void setEmbedMetadata(bool embedMetadata);
        /**
         * @brief Gets whether or not to crop thumbnails as square for audio files.
         * @return True to crop audio thumbnails, else false
         */
        bool getCropAudioThumbnails() const;
        /**
         * @brief Sets whether or not to crop thumbnails as square for audio files.
         * @param cropAudioThumbnails True to crop audio thumbnails, else false
         */
        void setCropAudioThumbnails(bool cropAudioThumbnails);
        /**
         * @brief Gets whether or not to remove source data from metadata.
         * @return True to remove source data, else false
         */
        bool getRemoveSourceData() const;
        /**
         * @brief Sets whether or not to remove source data from metadata.
         * @param removeSourceData True to remove source data, else false
         */
        void setRemoveSourceData(bool removeSourceData);
        /**
         * @brief Gets whether or not to embed chapters.
         * @return True to embed chapters, else false
         */
        bool getEmbedChapters() const;
        /**
         * @brief Sets whether or not to embed chapters.
         * @param embedChapters True to embed chapters, else false
         */
        void setEmbedChapters(bool embedChapters);
        /**
         * @brief Gets whether or not to embed subtitles.
         * @return True to embed subtitles, else false
         */
        bool getEmbedSubtitles() const;
        /**
         * @brief Sets whether or not to embed subtitles.
         * @param embedSubtitles True to embed subtitles, else false
         */
        void setEmbedSubtitles(bool embedSubtitles);
        /**
         * @brief Gets the previous save folder.
         * @return The previous save folder
         */
        std::filesystem::path getPreviousSaveFolder() const;
        /**
         * @brief Sets the previous save folder.
         * @param previousSaveFolder The new previous save folder
         */
        void setPreviousSaveFolder(const std::filesystem::path& previousSaveFolder);
        /**
         * @brief Gets the previous media file type.
         * @return The previous media file type
         */
        MediaFileType getPreviousMediaFileType() const;
        /**
         * @brief Sets the previous media file type.
         * @param previousMediaFileType The new previous media file type
         */
        void setPreviousMediaFileType(const MediaFileType& previousMediaFileType);
        /**
         * @brief Gets the previous generic media file type.
         * @return The previous generic media file type
         */
        MediaFileType getPreviousGenericMediaFileType() const;
        /**
         * @brief Sets the previous generic media file type.
         * @param previousGenericMediaFileType The new previous generic media file type
         */
        void setPreviousGenericMediaFileType(const MediaFileType& previousGenericMediaFileType);
        /**
         * @brief Gets the previous video resolution.
         * @return The previous video resolution
         */
        VideoResolution getPreviousVideoResolution() const;
        /**
         * @brief Sets the previous video resolution.
         * @param previousVideoResolution The new previous video resolution
         */
        void setPreviousVideoResolution(const VideoResolution& previousVideoResolution);
        /**
         * @brief Gets the previous subtitle state.
         * @return The previous subtitle state
         */
        bool getPreviousSubtitleState() const;
        /**
         * @brief Sets the previous subtitle state.
         * @param previousSubtitleState The new previous subtitle state
         */
        void setPreviousSubtitleState(bool previousSubtitleState);
        /**
         * @brief Gets the previous prefer AV1 state.
         * @return The previous prefer AV1 state
         */
        bool getPreviousPreferAV1State() const;
        /**
         * @brief Sets the previous prefer AV1 state.
         * @param previousPreferAV1State The new previous prefer AV1 state
         */
        void setPreviousPreferAV1State(bool previousPreferAV1State);
        /**
         * @brief Gets whether or not to number titles in playlists.
         * @return True to number titles, else false
         */
        bool getNumberTitles() const;
        /**
         * @brief Sets whether or not to number titles in playlists.
         * @param numberTitles True to number titles, else false
         */
        void setNumberTitles(bool numberTitles);
        /**
         * @brief Gets whether or not to show the disclaimer on startup.
         * @return True to show the disclaimer, else false
         */
        bool getShowDisclaimerOnStartup() const;
        /**
         * @brief Sets whether or not to show the disclaimer on startup.
         * @param showDisclaimerOnStartup True to show the disclaimer, else false
         */
        void setShowDisclaimerOnStartup(bool showDisclaimerOnStartup);
    };
}

#endif //CONFIGURATION_H