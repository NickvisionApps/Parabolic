#include "views/settingsdialog.h"
#include <QApplication>
#include <QComboBox>
#include <QFileDialog>
#include <QFormLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QListWidget>
#include <QMenu>
#include <QMessageBox>
#include <QPushButton>
#include <QSpinBox>
#include <QStackedWidget>
#include <QStyleHints>
#include <libnick/localization/gettext.h>
#include <libnick/system/environment.h>
#include <oclero/qlementine/widgets/LineEdit.hpp>
#include <oclero/qlementine/widgets/Switch.hpp>
#include "helpers/qthelpers.h"

using namespace Nickvision::System;
using namespace Nickvision::TubeConverter::Shared::Controllers;
using namespace Nickvision::TubeConverter::Shared::Models;
using namespace Nickvision::TubeConverter::Qt::Helpers;
using namespace oclero::qlementine;

namespace Ui
{
    class SettingsDialog
    {
    public:
        void setupUi(Nickvision::TubeConverter::Qt::Views::SettingsDialog* parent, int maxPostprocessingThreads)
        {
            viewStack = new QStackedWidget(parent);
            QFont boldFont;
            boldFont.setBold(true);
            //User Interface Page
            QLabel* lblTheme{ new QLabel(parent) };
            lblTheme->setText(_("Theme"));
            cmbTheme = new QComboBox(parent);
            cmbTheme->addItem(_("Light"));
            cmbTheme->addItem(_("Dark"));
            cmbTheme->addItem(_("System"));
            QLabel* lblUpdates{ new QLabel(parent) };
            lblUpdates->setText(_("Automatically Check for Updates"));
            chkUpdates = new Switch(parent);
            QLabel* lblPreventSuspend{ new QLabel(parent) };
            lblPreventSuspend->setText(_("Prevent Suspend"));
            lblPreventSuspend->setToolTip(_("Parabolic will prevent the computer from sleeping while downloads are running."));
            chkPreventSuspend = new Switch(parent);
            chkPreventSuspend->setToolTip(_("Parabolic will prevent the computer from sleeping while downloads are running."));
            QLabel* lblHistoryLength{ new QLabel(parent) };
            lblHistoryLength->setText(_("Download History Length"));
            lblHistoryLength->setToolTip(_("The amount of time to keep past downloads in the app's history."));
            cmbHistoryLength = new QComboBox(parent);
            cmbHistoryLength->setToolTip(_("The amount of time to keep past downloads in the app's history."));
            cmbHistoryLength->addItem(_("Never"));
            cmbHistoryLength->addItem(_("One Day"));
            cmbHistoryLength->addItem(_("One Week"));
            cmbHistoryLength->addItem(_("One Month"));
            cmbHistoryLength->addItem(_("Three Months"));
            cmbHistoryLength->addItem(_("Forever"));
            QFormLayout* layoutUserInterface{ new QFormLayout() };
            layoutUserInterface->addRow(lblTheme, cmbTheme);
            layoutUserInterface->addRow(lblUpdates, chkUpdates);
            layoutUserInterface->addRow(lblPreventSuspend, chkPreventSuspend);
            layoutUserInterface->addRow(lblHistoryLength, cmbHistoryLength);
            QWidget* userInterfacePage{ new QWidget(parent) };
            userInterfacePage->setLayout(layoutUserInterface);
            viewStack->addWidget(userInterfacePage);
            //Downloads Page
            QLabel* lblMaxNumberOfActiveDownloads{ new QLabel(parent) };
            lblMaxNumberOfActiveDownloads->setText(_("Max Number of Running Downloads"));
            spnMaxNumberOfActiveDownloads = new QSpinBox(parent);
            spnMaxNumberOfActiveDownloads->setMinimum(1);
            spnMaxNumberOfActiveDownloads->setMaximum(10);
            QLabel* lblOverwriteExistingFiles{ new QLabel(parent) };
            lblOverwriteExistingFiles->setText(_("Overwrite Existing Files"));
            chkOverwriteExistingFiles = new Switch(parent);
            lblLimitCharacters = new QLabel(parent);
            lblLimitCharacters->setText(_("Limit Filename Characters"));
            lblLimitCharacters->setToolTip(_("Parabolic will restrict characters in filenames to those supported only by Windows."));
            chkLimitCharacters = new Switch(parent);
            chkLimitCharacters->setToolTip(_("Parabolic will restrict characters in filenames to those supported only by Windows."));
            QLabel* lblIncludeMediaId{ new QLabel(parent) };
            lblIncludeMediaId->setText(_("Include Media Id in Title"));
            lblIncludeMediaId->setToolTip(_("Parabolic will include the media's id in its default title."));
            chkIncludeMediaId = new Switch(parent);
            chkIncludeMediaId->setToolTip(_("Parabolic will include the media's id in its default title."));
            QLabel* lblIncludeAutoGeneratedSubtitles{ new QLabel(parent) };
            lblIncludeAutoGeneratedSubtitles->setText(_("Include Auto-Generated Subtitles"));
            lblIncludeAutoGeneratedSubtitles->setToolTip(_("Parabolic will present auto-generated subtitles to download in addition to available subtitles."));
            chkIncludeAutoGeneratedSubtitles = new Switch(parent);
            chkIncludeAutoGeneratedSubtitles->setToolTip(_("Parabolic will present auto-generated subtitles to download in addition to available subtitles."));
            QLabel* lblPreferredVideoCodec{ new QLabel(parent) };
            lblPreferredVideoCodec->setText(_("Preferred Video Codec"));
            lblPreferredVideoCodec->setToolTip(_("The video codec Parabolic should prefer when parsing media formats to download."));
            cmbPreferredVideoCodec = new QComboBox(parent);
            cmbPreferredVideoCodec->setToolTip(_("The video codec Parabolic should prefer when parsing media formats to download."));
            cmbPreferredVideoCodec->addItem(_("Any"));
            cmbPreferredVideoCodec->addItem("VP9");
            cmbPreferredVideoCodec->addItem("AV1");
            cmbPreferredVideoCodec->addItem(_("H.264 (AVC)"));
            cmbPreferredVideoCodec->addItem(_("H.265 (HEVC)"));
            QLabel* lblPreferredAudioCodec{ new QLabel(parent) };
            lblPreferredAudioCodec->setText(_("Preferred Audio Codec"));
            lblPreferredAudioCodec->setToolTip(_("The audio codec Parabolic should prefer when parsing media formats to download."));
            cmbPreferredAudioCodec = new QComboBox(parent);
            cmbPreferredAudioCodec->setToolTip(_("The audio codec Parabolic should prefer when parsing media formats to download."));
            cmbPreferredAudioCodec->addItem(_("Any"));
            cmbPreferredAudioCodec->addItem(_("FLAC (ALAC)"));
            cmbPreferredAudioCodec->addItem(_("WAV (AIFF)"));
            cmbPreferredAudioCodec->addItem("OPUS");
            cmbPreferredAudioCodec->addItem("AAC");
            cmbPreferredAudioCodec->addItem("MP4A");
            cmbPreferredAudioCodec->addItem("MP3");
            QLabel* lblPreferredSubtitleFormat{ new QLabel(parent) };
            lblPreferredSubtitleFormat->setText(_("Preferred Subtitle Format"));
            lblPreferredSubtitleFormat->setToolTip(_("The file format Parabolic should ensure all subtitles are downloaded as."));
            cmbPreferredSubtitleFormat = new QComboBox(parent);
            cmbPreferredSubtitleFormat->setToolTip(_("The file format Parabolic should ensure all subtitles are downloaded as."));
            cmbPreferredSubtitleFormat->addItem(_("Any"));
            cmbPreferredSubtitleFormat->addItem("VTT");
            cmbPreferredSubtitleFormat->addItem("SRT");
            cmbPreferredSubtitleFormat->addItem("ASS");
            cmbPreferredSubtitleFormat->addItem("LRC");
            QFormLayout* layoutDownloads{ new QFormLayout() };
            layoutDownloads->addRow(lblMaxNumberOfActiveDownloads, spnMaxNumberOfActiveDownloads);
            layoutDownloads->addRow(lblOverwriteExistingFiles, chkOverwriteExistingFiles);
            layoutDownloads->addRow(lblLimitCharacters, chkLimitCharacters);
            layoutDownloads->addRow(lblIncludeMediaId, chkIncludeMediaId);
            layoutDownloads->addRow(lblIncludeAutoGeneratedSubtitles, chkIncludeAutoGeneratedSubtitles);
            layoutDownloads->addRow(lblPreferredVideoCodec, cmbPreferredVideoCodec);
            layoutDownloads->addRow(lblPreferredAudioCodec, cmbPreferredAudioCodec);
            layoutDownloads->addRow(lblPreferredSubtitleFormat, cmbPreferredSubtitleFormat);
            QWidget* downloadsPage{ new QWidget(parent) };
            downloadsPage->setLayout(layoutDownloads);
            viewStack->addWidget(downloadsPage);
            //Downloader Page
            QLabel* lblUsePartFiles{ new QLabel(parent) };
            lblUsePartFiles->setText(_("Use Part Files"));
            lblUsePartFiles->setToolTip(_("Parabolic will download media in separate .part files instead of directly into the output file."));
            chkUsePartFiles = new Switch(parent);
            chkUsePartFiles->setToolTip(_("Parabolic will download media in separate .part files instead of directly into the output file."));
            QLabel* lblSponsorBlock{ new QLabel(parent) };
            lblSponsorBlock->setText(_("Use SponsorBlock for YouTube"));
            lblSponsorBlock->setToolTip(_("Parabolic will attempt to remove sponsored segments from YouTube videos."));
            chkSponsorBlock = new Switch(parent);
            chkSponsorBlock->setToolTip(_("Parabolic will attempt to remove sponsored segments from YouTube videos."));
            QLabel* lblLimitSpeed{ new QLabel(parent) };
            lblLimitSpeed->setText(_("Limit Download Speed"));
            chkLimitSpeed = new Switch(parent);
            QObject::connect(chkLimitSpeed, &Switch::toggled, [this](bool checked)
            {
                spnSpeedLimit->setEnabled(checked);
            });
            QLabel* lblSpeedLimit{ new QLabel(parent) };
            lblSpeedLimit->setText(_("Speed Limit"));
            spnSpeedLimit = new QSpinBox(parent);
            spnSpeedLimit->setMinimum(512);
            spnSpeedLimit->setMaximum(10240);
            spnSpeedLimit->setSingleStep(512);
            spnSpeedLimit->setValue(1024);
            QLabel* lblProxyUrl{ new QLabel(parent) };
            lblProxyUrl->setText(_("Proxy URL"));
            txtProxyUrl = new LineEdit(parent);
            txtProxyUrl->setPlaceholderText(_("Enter proxy url here"));
            lblCookiesBrowser = new QLabel(parent);
            lblCookiesBrowser->setText(_("Cookies from Browser"));
            cmbCookiesBrowser = new QComboBox(parent);
            cmbCookiesBrowser->addItem(_("None"));
            cmbCookiesBrowser->addItem(_("Brave"));
            cmbCookiesBrowser->addItem(_("Chrome"));
            cmbCookiesBrowser->addItem(_("Chromium"));
            cmbCookiesBrowser->addItem(_("Edge"));
            cmbCookiesBrowser->addItem(_("Firefox"));
            cmbCookiesBrowser->addItem(_("Opera"));
            cmbCookiesBrowser->addItem(_("Safari"));
            cmbCookiesBrowser->addItem(_("Vivaldi"));
            cmbCookiesBrowser->addItem(_("Whale"));
            QLabel* lblCookiesFile{ new QLabel(parent) };
            lblCookiesFile->setText(_("Cookies File"));
            txtCookiesFile = new LineEdit(parent);
            txtCookiesFile->setReadOnly(true);
            txtCookiesFile->setPlaceholderText(_("No file selected"));
            btnSelectCookiesFile = new QPushButton(parent);
            btnSelectCookiesFile->setAutoDefault(false);
            btnSelectCookiesFile->setDefault(false);
            btnSelectCookiesFile->setIcon(QLEMENTINE_ICON(Document_Open));
            btnSelectCookiesFile->setText(_("Select Cookies File"));
            btnClearCookiesFile = new QPushButton(parent);
            btnClearCookiesFile->setAutoDefault(false);
            btnClearCookiesFile->setDefault(false);
            btnClearCookiesFile->setIcon(QLEMENTINE_ICON(Action_Close));
            btnClearCookiesFile->setText(_("Clear Cookies File"));
            QFormLayout* layoutDownloader{ new QFormLayout() };
            layoutDownloader->addRow(lblUsePartFiles, chkUsePartFiles);
            layoutDownloader->addRow(lblSponsorBlock, chkSponsorBlock);
            layoutDownloader->addRow(lblLimitSpeed, chkLimitSpeed);
            layoutDownloader->addRow(lblSpeedLimit, spnSpeedLimit);
            layoutDownloader->addRow(lblProxyUrl, txtProxyUrl);
            layoutDownloader->addRow(lblCookiesBrowser, cmbCookiesBrowser);
            layoutDownloader->addRow(lblCookiesFile, txtCookiesFile);
            layoutDownloader->addRow(nullptr, btnSelectCookiesFile);
            layoutDownloader->addRow(nullptr, btnClearCookiesFile);
            QWidget* downloaderPage{ new QWidget(parent) };
            downloaderPage->setLayout(layoutDownloader);
            viewStack->addWidget(downloaderPage);
            //Converter Page
            QLabel* lblEmbedMetadata{ new QLabel(parent) };
            lblEmbedMetadata->setText(_("Embed Metadata"));
            chkEmbedMetadata = new Switch(parent);
            QObject::connect(chkEmbedMetadata, &Switch::toggled, [this](bool checked)
            {
                chkRemoveSourceData->setEnabled(checked);
            });
            QLabel* lblRemoveSourceData{ new QLabel(parent) };
            lblRemoveSourceData->setText(_("Remove Source Data"));
            lblRemoveSourceData->setToolTip(_("Parabolic will clear metadata fields containing identifying download information."));
            chkRemoveSourceData = new Switch(parent);
            chkRemoveSourceData->setToolTip(_("Parabolic will clear metadata fields containing identifying download information."));
            QLabel* lblEmbedThumbnails{ new QLabel(parent) };
            lblEmbedThumbnails->setText(_("Embed Thumbnails"));
            lblEmbedThumbnails->setToolTip(_("If the file type does not support embedding, the thumbnail will be written to a separate image file."));
            chkEmbedThumbnails = new Switch(parent);
            chkEmbedThumbnails->setToolTip(_("If the file type does not support embedding, the thumbnail will be written to a separate image file."));
            QObject::connect(chkEmbedThumbnails, &Switch::toggled, [this](bool checked)
            {
                chkCropAudioThumbnails->setEnabled(checked);
            });
            QLabel* lblCropAudioThumbnails{ new QLabel(parent) };
            lblCropAudioThumbnails->setText(_("Crop Audio Thumbnails"));
            lblCropAudioThumbnails->setToolTip(_("Parabolic will crop thumbnails of audio files to squares."));
            chkCropAudioThumbnails = new Switch(parent);
            chkCropAudioThumbnails->setToolTip(_("Parabolic will crop thumbnails of audio files to squares."));
            QLabel* lblEmbedChapters{ new QLabel(parent) };
            lblEmbedChapters->setText(_("Embed Chapters"));
            chkEmbedChapters = new Switch(parent);
            QLabel* lblEmbedSubtitles{ new QLabel(parent) };
            lblEmbedSubtitles->setText(_("Embed Subtitles"));
            lblEmbedSubtitles->setToolTip(_("If disabled or if embedding is not supported, downloaded subtitles will be saved to separate files."));
            chkEmbedSubtitles = new Switch(parent);
            chkEmbedSubtitles->setToolTip(_("If disabled or if embedding is not supported, downloaded subtitles will be saved to separate files."));
            QFormLayout* layoutConverter{ new QFormLayout() };
            layoutConverter->addRow(lblEmbedMetadata, chkEmbedMetadata);
            layoutConverter->addRow(lblRemoveSourceData, chkRemoveSourceData);
            layoutConverter->addRow(lblEmbedThumbnails, chkEmbedThumbnails);
            layoutConverter->addRow(lblCropAudioThumbnails, chkCropAudioThumbnails);
            layoutConverter->addRow(lblEmbedChapters, chkEmbedChapters);
            layoutConverter->addRow(lblEmbedSubtitles, chkEmbedSubtitles);
            QWidget* converterPage{ new QWidget(parent) };
            converterPage->setLayout(layoutConverter);
            viewStack->addWidget(converterPage);
            //Postprocessing Page
            QLabel* lblPostprocessingThreads{ new QLabel(parent) };
            lblPostprocessingThreads->setText(_("FFmpeg Threads"));
            lblPostprocessingThreads->setToolTip(_("Parabolic will limit the number of threads used by ffmpeg."));
            spnPostprocessingThreads = new QSpinBox(parent);
            spnPostprocessingThreads->setToolTip(_("Parabolic will limit the number of threads used by ffmpeg."));
            spnPostprocessingThreads->setMinimum(1);
            spnPostprocessingThreads->setMaximum(maxPostprocessingThreads);
            QLabel* lblArguments{ new QLabel(parent) };
            lblArguments->setText(_("Arguments"));
            lblArguments->setFont(boldFont);
            QLabel* lblArgumentsDescription{ new QLabel(parent) };
            lblArgumentsDescription->setText(_("Parabolic will show these arguments for\nselection in the add download dialog."));
            btnAddPostprocessingArgument = new QPushButton(parent);
            btnAddPostprocessingArgument->setAutoDefault(true);
            btnAddPostprocessingArgument->setDefault(true);
            btnAddPostprocessingArgument->setIcon(QLEMENTINE_ICON(Action_Plus));
            btnAddPostprocessingArgument->setText(_("Add"));
            btnAddPostprocessingArgument->setToolTip(_("Add Postprocessing Argument"));
            listPostprocessingArguments = new QListWidget(parent);
            listPostprocessingArguments->setContextMenuPolicy(::Qt::ContextMenuPolicy::CustomContextMenu);
            QVBoxLayout* layoutLabels{ new QVBoxLayout() };
            layoutLabels->addWidget(lblArguments);
            layoutLabels->addWidget(lblArgumentsDescription);
            QHBoxLayout* layoutHeader{ new QHBoxLayout() };
            layoutHeader->addLayout(layoutLabels);
            layoutHeader->addStretch();
            layoutHeader->addWidget(btnAddPostprocessingArgument);
            QFormLayout* layoutThreads{ new QFormLayout() };
            layoutThreads->addRow(lblPostprocessingThreads, spnPostprocessingThreads);
            QVBoxLayout* layoutPostprocessing{ new QVBoxLayout() };
            layoutPostprocessing->addLayout(layoutThreads);
            layoutPostprocessing->addWidget(QtHelpers::createHLine(parent));
            layoutPostprocessing->addLayout(layoutHeader);
            layoutPostprocessing->addWidget(listPostprocessingArguments);
            QWidget* postprocessingPage{ new QWidget(parent) };
            postprocessingPage->setLayout(layoutPostprocessing);
            viewStack->addWidget(postprocessingPage);
            //aria2 Page
            QLabel* lblUseAria{ new QLabel(parent) };
            lblUseAria->setText(_("Use aria2c"));
            lblUseAria->setToolTip(_("Parabolic will use aria2c instead of yt-dlp's native downloader."));
            chkUseAria = new Switch(parent);
            chkUseAria->setToolTip(_("Parabolic will use aria2c instead of yt-dlp's native downloader."));
            QLabel* lblAriaMaxConnectionsPerServer{ new QLabel(parent) };
            lblAriaMaxConnectionsPerServer->setText(_("Max Connections Per Server (-x)"));
            spnAriaMaxConnectionsPerServer = new QSpinBox(parent);
            spnAriaMaxConnectionsPerServer->setMinimum(1);
            spnAriaMaxConnectionsPerServer->setMaximum(16);
            QLabel* lblAriaMinSplitSize{ new QLabel(parent) };
            lblAriaMinSplitSize->setText(_("Minimum Split Size (-k)"));
            lblAriaMinSplitSize->setToolTip(_("The minimum size of which to split a file (in MiB)."));
            spnAriaMinSplitSize = new QSpinBox(parent);
            spnAriaMinSplitSize->setToolTip(_("The minimum size of which to split a file (in MiB)."));
            spnAriaMinSplitSize->setMinimum(1);
            spnAriaMinSplitSize->setMaximum(1024);
            QFormLayout* layoutAria{ new QFormLayout() };
            layoutAria->addRow(lblUseAria, chkUseAria);
            layoutAria->addRow(lblAriaMaxConnectionsPerServer, spnAriaMaxConnectionsPerServer);
            layoutAria->addRow(lblAriaMinSplitSize, spnAriaMinSplitSize);
            QWidget* ariaPage{ new QWidget(parent) };
            ariaPage->setLayout(layoutAria);
            viewStack->addWidget(ariaPage);
            //Navigation List
            listNavigation = new QListWidget(parent);
            listNavigation->setMaximumWidth(160);
            listNavigation->setEditTriggers(QAbstractItemView::EditTrigger::NoEditTriggers);
            listNavigation->setDropIndicatorShown(false);
            listNavigation->addItem(new QListWidgetItem(QLEMENTINE_ICON(Navigation_UiPanelLeft), _("User Interface"), listNavigation));
            listNavigation->addItem(new QListWidgetItem(QLEMENTINE_ICON(Misc_ItemsList), _("Downloads"), listNavigation));
            listNavigation->addItem(new QListWidgetItem(QLEMENTINE_ICON(Action_Download), _("Downloader"), listNavigation));
            listNavigation->addItem(new QListWidgetItem(QLEMENTINE_ICON(Misc_Tool), _("Converter"), listNavigation));
            listNavigation->addItem(new QListWidgetItem(QLEMENTINE_ICON(Misc_Fx), _("Postprocessing"), listNavigation));
            listNavigation->addItem(new QListWidgetItem(QLEMENTINE_ICON(Software_CommandLine), _("aria2c"), listNavigation));
            QObject::connect(listNavigation, &QListWidget::currentRowChanged, [this]()
            {
                viewStack->setCurrentIndex(listNavigation->currentRow());
            });
            //Main Layout
            QHBoxLayout* layout{ new QHBoxLayout() };
            layout->addWidget(listNavigation);
            layout->addWidget(viewStack);
            parent->setLayout(layout);
        }

        QListWidget* listNavigation;
        QStackedWidget* viewStack;
        QComboBox* cmbTheme;
        Switch* chkUpdates;
        Switch* chkPreventSuspend;
        QComboBox* cmbHistoryLength;
        QSpinBox* spnMaxNumberOfActiveDownloads;
        Switch* chkOverwriteExistingFiles;
        QLabel* lblLimitCharacters;
        Switch* chkLimitCharacters;
        Switch* chkIncludeMediaId;
        Switch* chkIncludeAutoGeneratedSubtitles;
        QComboBox* cmbPreferredVideoCodec;
        QComboBox* cmbPreferredAudioCodec;
        QComboBox* cmbPreferredSubtitleFormat;
        Switch* chkUsePartFiles;
        Switch* chkSponsorBlock;
        Switch* chkLimitSpeed;
        QSpinBox* spnSpeedLimit;
        LineEdit* txtProxyUrl;
        QLabel* lblCookiesBrowser;
        QComboBox* cmbCookiesBrowser;
        LineEdit* txtCookiesFile;
        QPushButton* btnSelectCookiesFile;
        QPushButton* btnClearCookiesFile;
        Switch* chkEmbedMetadata;
        Switch* chkRemoveSourceData;
        Switch* chkEmbedThumbnails;
        Switch* chkCropAudioThumbnails;
        Switch* chkEmbedChapters;
        Switch* chkEmbedSubtitles;
        QSpinBox* spnPostprocessingThreads;
        QPushButton* btnAddPostprocessingArgument;
        QListWidget* listPostprocessingArguments;
        Switch* chkUseAria;
        QSpinBox* spnAriaMaxConnectionsPerServer;
        QSpinBox* spnAriaMinSplitSize;
    };
}

namespace Nickvision::TubeConverter::Qt::Views
{
    SettingsDialog::SettingsDialog(const std::shared_ptr<PreferencesViewController>& controller, oclero::qlementine::ThemeManager* themeManager, QWidget* parent)
        : QDialog{ parent },
        m_ui{ new Ui::SettingsDialog() },
        m_controller{ controller },
        m_themeManager{ themeManager }
    {
        //Dialog Settings
        setWindowTitle(_("Settings"));
        setMinimumSize(600, 400);
        setModal(true);
        //Load Ui
        m_ui->setupUi(this, m_controller->getMaxPostprocessingThreads());
        DownloaderOptions options{ m_controller->getDownloaderOptions() };
        m_ui->cmbTheme->setCurrentIndex(static_cast<int>(m_controller->getTheme()));
        m_ui->chkUpdates->setChecked(m_controller->getAutomaticallyCheckForUpdates());
        m_ui->chkPreventSuspend->setChecked(m_controller->getPreventSuspend());
        m_ui->cmbHistoryLength->setCurrentIndex(static_cast<int>(m_controller->getHistoryLengthIndex()));
        m_ui->spnMaxNumberOfActiveDownloads->setValue(options.getMaxNumberOfActiveDownloads());
        m_ui->chkOverwriteExistingFiles->setChecked(options.getOverwriteExistingFiles());
        m_ui->chkLimitCharacters->setChecked(options.getLimitCharacters());
        m_ui->chkIncludeMediaId->setChecked(options.getIncludeMediaIdInTitle());
        m_ui->chkIncludeAutoGeneratedSubtitles->setChecked(options.getIncludeAutoGeneratedSubtitles());
        m_ui->cmbPreferredVideoCodec->setCurrentIndex(static_cast<int>(options.getPreferredVideoCodec()));
        m_ui->cmbPreferredAudioCodec->setCurrentIndex(static_cast<int>(options.getPreferredAudioCodec()));
        m_ui->cmbPreferredSubtitleFormat->setCurrentIndex(static_cast<int>(options.getPreferredSubtitleFormat()));
        m_ui->chkUsePartFiles->setChecked(options.getUsePartFiles());
        m_ui->chkSponsorBlock->setChecked(options.getYouTubeSponsorBlock());
        m_ui->chkLimitSpeed->setChecked(options.getSpeedLimit().has_value());
        m_ui->spnSpeedLimit->setEnabled(options.getSpeedLimit().has_value());
        if(options.getSpeedLimit())
        {
            m_ui->spnSpeedLimit->setValue(*options.getSpeedLimit());
        }
        m_ui->txtProxyUrl->setText(QString::fromStdString(options.getProxyUrl()));
        m_ui->cmbCookiesBrowser->setCurrentIndex(static_cast<int>(options.getCookiesBrowser()));
        m_ui->txtCookiesFile->setText(QString::fromStdString(options.getCookiesPath().filename().string()));
        m_ui->txtCookiesFile->setToolTip(QString::fromStdString(options.getCookiesPath().string()));
        m_ui->chkEmbedMetadata->setChecked(options.getEmbedMetadata());
        m_ui->chkRemoveSourceData->setChecked(options.getRemoveSourceData());
        m_ui->chkRemoveSourceData->setEnabled(options.getEmbedMetadata());
        m_ui->chkEmbedThumbnails->setChecked(options.getEmbedThumbnails());
        m_ui->chkCropAudioThumbnails->setChecked(options.getCropAudioThumbnails());
        m_ui->chkCropAudioThumbnails->setEnabled(options.getEmbedThumbnails());
        m_ui->chkEmbedChapters->setChecked(options.getEmbedChapters());
        m_ui->chkEmbedSubtitles->setChecked(options.getEmbedSubtitles());
        m_ui->spnPostprocessingThreads->setValue(options.getPostprocessingThreads());
        m_ui->chkUseAria->setChecked(options.getUseAria());
        m_ui->spnAriaMaxConnectionsPerServer->setValue(options.getAriaMaxConnectionsPerServer());
        m_ui->spnAriaMinSplitSize->setValue(options.getAriaMinSplitSize());
        if(Environment::getDeploymentMode() != DeploymentMode::Local)
        {
            m_ui->lblCookiesBrowser->setVisible(false);
            m_ui->cmbCookiesBrowser->setVisible(false);
        }
        if(Environment::getOperatingSystem() == OperatingSystem::Windows)
        {
            m_ui->lblLimitCharacters->setVisible(false);
            m_ui->chkLimitCharacters->setVisible(false);
        }
        m_ui->listNavigation->setCurrentRow(0);
        reloadPostprocessingArguments();
        //Signals
        connect(m_ui->cmbTheme, &QComboBox::currentIndexChanged, this, &SettingsDialog::onThemeChanged);
        connect(m_ui->btnSelectCookiesFile, &QPushButton::clicked, this, &SettingsDialog::selectCookiesFile);
        connect(m_ui->btnClearCookiesFile, &QPushButton::clicked, this, &SettingsDialog::clearCookiesFile);
        connect(m_ui->btnAddPostprocessingArgument, &QPushButton::clicked, this, &SettingsDialog::addPostprocessingArgument);
        connect(m_ui->listPostprocessingArguments, &QListWidget::customContextMenuRequested, this, &SettingsDialog::onListPostprocessignArgumentsContextMenu);
        connect(m_ui->listPostprocessingArguments, &QListWidget::itemDoubleClicked, this, &SettingsDialog::onPostprocessingArgumentDoubleClicked);
    }

    SettingsDialog::~SettingsDialog()
    {
        delete m_ui;
    }

    void SettingsDialog::closeEvent(QCloseEvent* event)
    {
        DownloaderOptions options{ m_controller->getDownloaderOptions() };
        m_controller->setTheme(static_cast<Shared::Models::Theme>(m_ui->cmbTheme->currentIndex()));
        m_controller->setAutomaticallyCheckForUpdates(m_ui->chkUpdates->isChecked());
        m_controller->setPreventSuspend(m_ui->chkPreventSuspend->isChecked());
        m_controller->setHistoryLengthIndex(m_ui->cmbHistoryLength->currentIndex());
        m_controller->setDownloaderOptions(options);
        options.setMaxNumberOfActiveDownloads(m_ui->spnMaxNumberOfActiveDownloads->value());
        options.setOverwriteExistingFiles(m_ui->chkOverwriteExistingFiles->isChecked());
        options.setLimitCharacters(m_ui->chkLimitCharacters->isChecked());
        options.setIncludeMediaIdInTitle(m_ui->chkIncludeMediaId->isChecked());
        options.setIncludeAutoGeneratedSubtitles(m_ui->chkIncludeAutoGeneratedSubtitles->isChecked());
        options.setPreferredVideoCodec(static_cast<VideoCodec>(m_ui->cmbPreferredVideoCodec->currentIndex()));
        options.setPreferredAudioCodec(static_cast<AudioCodec>(m_ui->cmbPreferredAudioCodec->currentIndex()));
        options.setPreferredSubtitleFormat(static_cast<SubtitleFormat>(m_ui->cmbPreferredSubtitleFormat->currentIndex()));
        options.setUsePartFiles(m_ui->chkUsePartFiles->isChecked());
        options.setYouTubeSponsorBlock(m_ui->chkSponsorBlock->isChecked());
        options.setSpeedLimit(m_ui->chkLimitSpeed->isChecked() ? std::make_optional<int>(m_ui->spnSpeedLimit->value()) : std::nullopt);
        options.setProxyUrl(m_ui->txtProxyUrl->text().toStdString());
        options.setCookiesBrowser(static_cast<Browser>(m_ui->cmbCookiesBrowser->currentIndex()));
        options.setCookiesPath(m_ui->txtCookiesFile->toolTip().toStdString());
        options.setEmbedMetadata(m_ui->chkEmbedMetadata->isChecked());
        options.setRemoveSourceData(m_ui->chkRemoveSourceData->isChecked());
        options.setEmbedThumbnails(m_ui->chkEmbedThumbnails->isChecked());
        options.setCropAudioThumbnails(m_ui->chkCropAudioThumbnails->isChecked());
        options.setEmbedChapters(m_ui->chkEmbedChapters->isChecked());
        options.setEmbedSubtitles(m_ui->chkEmbedSubtitles->isChecked());
        options.setPostprocessingThreads(m_ui->spnPostprocessingThreads->value());
        options.setUseAria(m_ui->chkUseAria->isChecked());
        options.setAriaMaxConnectionsPerServer(m_ui->spnAriaMaxConnectionsPerServer->value());
        options.setAriaMinSplitSize(m_ui->spnAriaMinSplitSize->value());
        m_controller->setDownloaderOptions(options);
        m_controller->saveConfiguration();
        event->accept();
    }

    void SettingsDialog::onThemeChanged()
    {
        switch (static_cast<Shared::Models::Theme>(m_ui->cmbTheme->currentIndex()))
        {
        case Shared::Models::Theme::Light:
            QApplication::styleHints()->setColorScheme(::Qt::ColorScheme::Light);
            m_themeManager->setCurrentTheme("Light");
            break;
        case Shared::Models::Theme::Dark:
            QApplication::styleHints()->setColorScheme(::Qt::ColorScheme::Dark);
            m_themeManager->setCurrentTheme("Dark");
            break;
        default:
            QApplication::styleHints()->unsetColorScheme();
            m_themeManager->setCurrentTheme(QApplication::styleHints()->colorScheme() == ::Qt::ColorScheme::Light ? "Light" : "Dark");
            break;
        }
    }

    void SettingsDialog::selectCookiesFile()
    {
        QString file{ QFileDialog::getOpenFileName(this, _("Select Cookies File"), {}, _("TXT Files (*.txt)")) };
        if(!file.isEmpty())
        {
            std::filesystem::path path{ file.toStdString() };
            m_ui->txtCookiesFile->setText(QString::fromStdString(path.filename().string()));
            m_ui->txtCookiesFile->setToolTip(QString::fromStdString(path.string()));
        }
    }

    void SettingsDialog::clearCookiesFile()
    {
        m_ui->txtCookiesFile->setText("");
        m_ui->txtCookiesFile->setToolTip("");
    }

    void SettingsDialog::addPostprocessingArgument()
    {
        //Add Argument Dialog
        QDialog* dialog{ new QDialog(this) };
        dialog->setMinimumSize(300, 360);
        dialog->setWindowTitle(_("New Argument"));
        QLabel* lblName{ new QLabel(dialog) };
        lblName->setText(_("Name"));
        QLineEdit* txtName{ new QLineEdit(dialog) };
        txtName->setPlaceholderText("Enter name here");
        QLabel* lblPostProcessor{ new QLabel(dialog) };
        lblPostProcessor->setText(_("Post Processor"));
        QComboBox* cmbPostProcessor{ new QComboBox(dialog) };
        QtHelpers::setComboBoxItems(cmbPostProcessor, m_controller->getPostProcessorStrings());
        QLabel* lblExecutable{ new QLabel(dialog) };
        lblExecutable->setText(_("Executable"));
        QComboBox* cmbExecutable{ new QComboBox(dialog) };
        QtHelpers::setComboBoxItems(cmbExecutable, m_controller->getExecutableStrings());
        QLabel* lblArgs{ new QLabel(dialog) };
        lblArgs->setText(_("Args"));
        QLineEdit* txtArgs{ new QLineEdit(dialog) };
        txtArgs->setPlaceholderText("Enter args here");
        QPushButton* btnAdd{ new QPushButton(dialog) };
        btnAdd->setAutoDefault(true);
        btnAdd->setDefault(true);
        btnAdd->setIcon(QLEMENTINE_ICON(Action_Plus));
        btnAdd->setText(_("Add"));
        QFormLayout* layoutForm{ new QFormLayout() };
        layoutForm->addRow(lblName, txtName);
        layoutForm->addRow(lblPostProcessor, cmbPostProcessor);
        layoutForm->addRow(lblExecutable, cmbExecutable);
        layoutForm->addRow(lblArgs, txtArgs);
        QVBoxLayout* layout{ new QVBoxLayout() };
        layout->addLayout(layoutForm);
        layout->addWidget(btnAdd);
        dialog->setLayout(layout);
        connect(btnAdd, &QPushButton::clicked, [&]()
        {
            PostProcessorArgumentCheckStatus status{ m_controller->addPostprocessingArgument(txtName->text().toStdString(), static_cast<PostProcessor>(cmbPostProcessor->currentIndex()), static_cast<Executable>(cmbExecutable->currentIndex()), txtArgs->text().toStdString()) };
            switch(status)
            {
            case PostProcessorArgumentCheckStatus::EmptyName:
                QMessageBox::critical(this, _("Error"), _("The argument name cannot be empty."), QMessageBox::Ok);
                break;
            case PostProcessorArgumentCheckStatus::ExistingName:
                QMessageBox::critical(this, _("Error"), _("An argument with this name already exists."), QMessageBox::Ok);
                break;
            case PostProcessorArgumentCheckStatus::EmptyArgs:
                QMessageBox::critical(this, _("Error"), _("The argument args cannot be empty."), QMessageBox::Ok);
                break;
            default:
                dialog->close();
                break;
            }
        });
        dialog->exec();
        reloadPostprocessingArguments();
    }

    void SettingsDialog::onListPostprocessignArgumentsContextMenu(const QPoint& pos)
    {
        QListWidgetItem* selected;
        if((selected = m_ui->listPostprocessingArguments->itemAt(pos)))
        {
            QMenu menu{ this };
            menu.addAction(QLEMENTINE_ICON(Misc_Pen), _("Edit Argument"), [this, selected]()
            {
                editPostprocessingArgument(selected->text());
            });
            menu.addAction(QLEMENTINE_ICON(Action_Trash), _("Delete Argument"), [this, selected]()
            {
                QMessageBox msgBox{ QMessageBox::Icon::Warning, _("Delete Argument?"), _("Are you sure you want to delete this argument?"), QMessageBox::StandardButton::Yes | QMessageBox::StandardButton::No, this };
                if(msgBox.exec() == QMessageBox::StandardButton::Yes)
                {
                    m_controller->deletePostprocessingArgument(selected->text().toStdString());
                    reloadPostprocessingArguments();
                }
            });
            menu.exec(mapToGlobal(pos));
        }
    }

    void SettingsDialog::onPostprocessingArgumentDoubleClicked(QListWidgetItem* item)
    {
        editPostprocessingArgument(item->text());
    }

    void SettingsDialog::editPostprocessingArgument(const QString& name)
    {
        std::optional<PostProcessorArgument> argument{ m_controller->getPostprocessingArgument(name.toStdString()) };
        if(!argument)
        {
            return;
        }
        //Edit Argument Dialog
        QDialog* dialog{ new QDialog(this) };
        dialog->setMinimumSize(300, 360);
        dialog->setWindowTitle(_("Edit Argument"));
        QLabel* lblName{ new QLabel(dialog) };
        lblName->setText(_("Name"));
        QLineEdit* txtName{ new QLineEdit(dialog) };
        txtName->setPlaceholderText("Enter name here");
        txtName->setText(QString::fromStdString(argument->getName()));
        txtName->setEnabled(false);
        QLabel* lblPostProcessor{ new QLabel(dialog) };
        lblPostProcessor->setText(_("Post Processor"));
        QComboBox* cmbPostProcessor{ new QComboBox(dialog) };
        QtHelpers::setComboBoxItems(cmbPostProcessor, m_controller->getPostProcessorStrings());
        cmbPostProcessor->setCurrentIndex(static_cast<int>(argument->getPostProcessor()));
        QLabel* lblExecutable{ new QLabel(dialog) };
        lblExecutable->setText(_("Executable"));
        QComboBox* cmbExecutable{ new QComboBox(dialog) };
        QtHelpers::setComboBoxItems(cmbExecutable, m_controller->getExecutableStrings());
        cmbExecutable->setCurrentIndex(static_cast<int>(argument->getExecutable()));
        QLabel* lblArgs{ new QLabel(dialog) };
        lblArgs->setText(_("Args"));
        QLineEdit* txtArgs{ new QLineEdit(dialog) };
        txtArgs->setPlaceholderText("Enter args here");
        txtArgs->setText(QString::fromStdString(argument->getArgs()));
        QPushButton* btnSave{ new QPushButton(dialog) };
        btnSave->setAutoDefault(true);
        btnSave->setDefault(true);
        btnSave->setIcon(QLEMENTINE_ICON(Action_Save));
        btnSave->setText(_("Save"));
        QPushButton* btnDelete{ new QPushButton(dialog) };
        btnDelete->setAutoDefault(false);
        btnDelete->setDefault(false);
        btnDelete->setIcon(QLEMENTINE_ICON(Action_Trash));
        btnDelete->setText(_("Delete"));
        QFormLayout* layoutForm{ new QFormLayout() };
        layoutForm->addRow(lblName, txtName);
        layoutForm->addRow(lblPostProcessor, cmbPostProcessor);
        layoutForm->addRow(lblExecutable, cmbExecutable);
        layoutForm->addRow(lblArgs, txtArgs);
        QHBoxLayout* layoutButtons{ new QHBoxLayout() };
        layoutButtons->addWidget(btnDelete);
        layoutButtons->addWidget(btnSave);
        QVBoxLayout* layout{ new QVBoxLayout() };
        layout->addLayout(layoutForm);
        layout->addLayout(layoutButtons);
        dialog->setLayout(layout);
        connect(btnSave, &QPushButton::clicked, [&]()
        {
            PostProcessorArgumentCheckStatus status{ m_controller->updatePostprocessingArgument(argument->getName(), static_cast<PostProcessor>(cmbPostProcessor->currentIndex()), static_cast<Executable>(cmbExecutable->currentIndex()), txtArgs->text().toStdString()) };
            switch(status)
            {
            case PostProcessorArgumentCheckStatus::EmptyArgs:
                QMessageBox::critical(this, _("Error"), _("The argument args cannot be empty."), QMessageBox::Ok);
                break;
            default:
                dialog->close();
                break;
            }
        });
        connect(btnDelete, &QPushButton::clicked, [&]()
        {
            QMessageBox msgBox{ QMessageBox::Icon::Warning, _("Delete Argument?"), _("Are you sure you want to delete this argument?"), QMessageBox::StandardButton::Yes | QMessageBox::StandardButton::No, this };
            if(msgBox.exec() == QMessageBox::StandardButton::Yes)
            {
                m_controller->deletePostprocessingArgument(argument->getName());
                dialog->close();
            }
        });
        dialog->exec();
        reloadPostprocessingArguments();
    }

    void SettingsDialog::reloadPostprocessingArguments()
    {
        m_ui->listPostprocessingArguments->clear();
        for(const PostProcessorArgument& argument : m_controller->getDownloaderOptions().getPostprocessingArguments())
        {
            QListWidgetItem* item{ new QListWidgetItem(QString::fromStdString(argument.getName()), m_ui->listPostprocessingArguments) };
            m_ui->listPostprocessingArguments->addItem(item);
        }
    }
}
